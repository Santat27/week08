name: CD - Deploy Backend Services to AKS

on:
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: 'Name of the AKS Cluster to deploy to'
        required: true
        default: 'week08aks'
      aks_resource_group:
        description: 'Resource Group of the AKS Cluster'
        required: true
        default: 'week08rg'
      aks_acr_name:
        description: 'Name of ACR'
        required: true
        default: 'week08acr'

jobs:
  deploy_backend:
    runs-on: ubuntu-latest
    environment: Production
    env:
      BACKEND_NS: week08

    # Use outputs produced by the wait step
    outputs:
      PRODUCT_API_IP: ${{ steps.wait_ips.outputs.product_ip }}
      ORDER_API_IP:   ${{ steps.wait_ips.outputs.order_ip }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          enable-AzPSSession: true

      - name: Set Kubernetes context (get AKS credentials)
        run: |
          az aks get-credentials \
            --resource-group "${{ github.event.inputs.aks_resource_group }}" \
            --name "${{ github.event.inputs.aks_cluster_name }}" \
            --overwrite-existing

      - name: Ensure namespace exists
        run: |
          kubectl get namespace "$BACKEND_NS" >/dev/null 2>&1 || \
          kubectl create namespace "$BACKEND_NS"

      - name: Grant AcrPull to AKS kubelet identity (policy-safe)
        run: |
          set -e
          ACR_ID=$(az acr show -n "${{ github.event.inputs.aks_acr_name }}" --query id -o tsv)

          # Try Managed Identity (most AKS clusters)
          KUBE_OID=$(az aks show \
            -g "${{ github.event.inputs.aks_resource_group }}" \
            -n "${{ github.event.inputs.aks_cluster_name }}" \
            --query "identityProfile.kubeletidentity.objectId" -o tsv 2>/dev/null || true)

          if [ -n "$KUBE_OID" ] && [ "$KUBE_OID" != "null" ]; then
            echo "Granting AcrPull to kubelet identity: $KUBE_OID"
            az role assignment create --assignee-object-id "$KUBE_OID" --role AcrPull --scope "$ACR_ID"
          else
            # Fallback: legacy SP-based cluster
            SP_APPID=$(az aks show \
              -g "${{ github.event.inputs.aks_resource_group }}" \
              -n "${{ github.event.inputs.aks_cluster_name }}" \
              --query "servicePrincipalProfile.clientId" -o tsv)
            echo "Granting AcrPull to cluster SP: $SP_APPID"
            az role assignment create --assignee "$SP_APPID" --role AcrPull --scope "$ACR_ID"
          fi

      - name: Deploy Backend Infrastructure (namespace+configs+DBs)
        run: |
          set -e
          kubectl apply -f k8s/configmaps.yaml  --namespace "$BACKEND_NS"
          kubectl apply -f k8s/secrets.yaml     --namespace "$BACKEND_NS"
          kubectl apply -f k8s/product-db.yaml  --namespace "$BACKEND_NS"
          kubectl apply -f k8s/order-db.yaml    --namespace "$BACKEND_NS"

      - name: Deploy Backend Microservices (Product, Order)
        run: |
          set -e
          kubectl apply --namespace "$BACKEND_NS" --filename k8s/product-service.yaml
          kubectl apply --namespace "$BACKEND_NS" --filename k8s/order-service.yaml

      - name: Debug svc names and types
        run: |
          echo "== Services in $BACKEND_NS =="
          kubectl -n "$BACKEND_NS" get svc -o wide
          echo "== Names and types =="
          kubectl -n "$BACKEND_NS" get svc -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.type}{"\n"}{end}'

      - name: Discover product/order service names
        id: discover
        run: |
          PRODUCT_SVC=$(kubectl -n "$BACKEND_NS" get svc -o jsonpath='{range .items[*]}{.metadata.name}{" "}{end}' | tr ' ' '\n' | grep -E '^product' | head -n1)
          ORDER_SVC=$(kubectl  -n "$BACKEND_NS" get svc -o jsonpath='{range .items[*]}{.metadata.name}{" "}{end}' | tr ' ' '\n' | grep -E '^order'   | head -n1)
          echo "product_svc=$PRODUCT_SVC" >> $GITHUB_OUTPUT
          echo "order_svc=$ORDER_SVC"     >> $GITHUB_OUTPUT
          echo "Detected: product=$PRODUCT_SVC order=$ORDER_SVC"

      - name: Wait for Backend LoadBalancer IPs
        id: wait_ips
        run: |
          set -e
          PRODUCT_SVC="${{ steps.discover.outputs.product_svc }}"
          ORDER_SVC="${{ steps.discover.outputs.order_svc }}"

          if [ -z "$PRODUCT_SVC" ] || [ -z "$ORDER_SVC" ]; then
            echo "Could not detect product/order service names. Check your k8s/*.yaml 'metadata.name'."
            exit 1
          fi

          echo "Waiting up to 10 minutes for External IPs..."
          for i in {1..120}; do
            PIP=$(kubectl -n "$BACKEND_NS" get svc "$PRODUCT_SVC" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)
            OIP=$(kubectl -n "$BACKEND_NS" get svc "$ORDER_SVC"  -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)

            # Some clusters set hostname instead of ip
            [ -z "$PIP" ] && PIP=$(kubectl -n "$BACKEND_NS" get svc "$PRODUCT_SVC" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            [ -z "$OIP" ] && OIP=$(kubectl -n "$BACKEND_NS" get svc "$ORDER_SVC"  -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)

            if [ -n "$PIP" ] && [ -n "$OIP" ]; then
              echo "product_ip=$PIP" >> $GITHUB_OUTPUT
              echo "order_ip=$OIP"   >> $GITHUB_OUTPUT
              echo "PRODUCT_IP=$PIP" >> $GITHUB_ENV
              echo "ORDER_IP=$OIP"   >> $GITHUB_ENV
              echo "Product IP: $PIP | Order IP: $OIP"
              exit 0
            fi

            echo "Attempt $i/120â€¦ still waiting."
            sleep 5
          done

          echo "Timed out waiting for LoadBalancer IPs"
          echo "=== Describe product svc ==="
          kubectl -n "$BACKEND_NS" describe svc "$PRODUCT_SVC" || true
          echo "=== Describe order svc ==="
          kubectl -n "$BACKEND_NS" describe svc "$ORDER_SVC"  || true
          exit 1

      - name: Azure Logout
        run: az logout
